<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>

    <meta charset="utf-8">
    <title>建筑</title>

    <script type="text/javascript" th:src="@{static/libs/three.js}"></script>
    <script type="text/javascript" th:src="@{static/libs/GLTFLoader.js}"></script>
    <script type="text/javascript" th:src="@{static/libs/RGBELoader.js}"></script>
    <script type="text/javascript" th:src="@{static/libs/OrbitControls.js}"></script>

    <div id="overlay">
        <button id="startButton">Play</button>
    </div>

    <div id="overlay1">
        <button id="pauseButton">Pause</button>
    </div>


    <video id="video" autoplay controls><!--loop crossOrigin="anonymous" playsinline style="display:none"-->
        <source src="static/video/4.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
    </video>

</head>
<body>
<script>
    //灵感1：资源文件里面有水滴的jpg，可以做一个配合现实天气的天气界面。
    //灵感2：房间贴纸分类：护眼色、经典色等。
    //灵感3：可加入"加载中"的动画
    //color:#ffffff;
    // 创建一个场景，将我们所有的元素，如物体，相机和灯光。

    var keyboard={}; //定义数组
    var player={height:1.8,speed:0.2,turnSpeed:Math.PI*0.01};
    var control;

    var scene= new THREE.Scene();
    var camera= new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight,0.1, 1000);
    var renderer=new THREE.WebGLRenderer({antialias:true});//防锯齿
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.shadowMap.enabled=true;
    renderer.shadowMap.type=THREE.BasicShadowMap;

    //场景美化效果
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    document.body.appendChild(renderer.domElement);
    var loadingManager=null,Resource_Loaded=true;
    var loadingScreen={  //“加载中”的场景
        scene:new THREE.Scene(),
        camera:new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight,0.1,100),
        ambientLight:new THREE.AmbientLight(0xffffff,0.8),//浅蓝色
        box:new THREE.Mesh(
            new THREE.BoxGeometry(1,1,1),
            new THREE.MeshPhongMaterial({
                color:0xff0000,
                wireframe:false
            })
            // 0xff0000 红色
            // 0x00ff00 绿色,
            // 0x0000ff 蓝色.
            // 0xffffff 白色
            // 0x000000 黑色
        )
    }

    //设置加载场景对象的一些属性
    loadingScreen.box.position.set(0,0,5);
    loadingScreen.camera.lookAt(loadingScreen.box.position);
    loadingScreen.scene.add(loadingScreen.box);
    loadingScreen.scene.add(loadingScreen.ambientLight);

    //实例化加载管理器
    loadingManager=new THREE.LoadingManager();
    //加载过程的方法一:加载过程
    loadingManager.onProgress=function(item,loaded,total){
        console.log(item,loaded,total); //console里面展示加载的项目、加载和完成
    }
    //方法二：加载完成
    loadingManager.onLoad=function(){  //必须是onLoad才行，不能是onload！！！
        console.log("已下载所有资源！");  //没有加载完资源
        Resource_Loaded=true;
       // onResourceLoaded(); //记得给所有loader加上（loadingManager）
    }

    //模型索引
    var model= {
        BigDataStudio:{
            GLTF:"static/models/gltf/Studio/BigDataStudio/",
            gltfobj:null
        }
    }
    //网格索引
    var meshes={};

    init();
    function init(){
        //initLight();
        //CreatePanl();
        //initControls();
        initVideo();

        // control = new THREE.OrbitControls( camera, document.body );
        // //control.enabled=false;
        // control.target=new THREE.Vector3(0,0,100);
        //control.target.set( 0, 0, 0 );
        // control.autoRotate = true;
        // control.autoRotateSpeed = - 1.0;
        //control.update();
    }




    //光源
    function initLight(){
        ambientLight=new THREE.AmbientLight(0xfffffff,0.5);//浅蓝色
        pointLight=new THREE.PointLight(0xfffffff,0.8,0.5);
        pointLight.position.set(0,0,0);
        pointLight.castShadow=true;
        scene.add(ambientLight);
        scene.add(pointLight);
    }


    camera.position.x = 0;
    camera.position.y = 80;
    camera.position.z =-80;
    camera.lookAt(0,0,100);
    scene.add(camera);



    //加载视频
    initVideo();
    function initVideo() {

        //辅助工具
        var helper = new THREE.AxesHelper(50);
        scene.add(helper);

        var play=new THREE.Mesh(
            new THREE.PlaneGeometry(10,10),
            new THREE.MeshBasicMaterial({color:0x00ff00})//绿色
        )
        play.name = 'play';
        console.log(play);
        play.position.set(120,150,90);
        play.rotation.x=Math.PI;
        scene.add(play);

        var pause=new THREE.Mesh(
            new THREE.PlaneGeometry(10,10),
            new THREE.MeshBasicMaterial({color:0xff0000})//红色
        )
        pause.name = 'pause';
        pause.position.set(120,130,90);
        pause.rotation.x=Math.PI;
        scene.add(pause);

        //添加立方体
        var geometry = new THREE.PlaneGeometry(200,150);

        //获取到video对象
        var video = document.querySelector("#video");
        //通过video对象实例化纹理
        var texture = new THREE.VideoTexture(video);
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;//使用平铺，因为视频尺寸不一定都是标准的
        texture.minFilter = THREE.LinearFilter;
        material = new THREE.MeshBasicMaterial( { map: texture } );
        var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh

        mesh.rotation.y=Math.PI;
        mesh.position.set(0,100,95);
        scene.add(mesh);
        //移除video标签的显示
        document.getElementById('video').style.display = 'none';

        var videoTime=0;
        window.onload=function() { //等所有都加载完了再执行function后面的
            var startButton = document.getElementById('startButton');
            startButton.addEventListener('click', function () {
                video = document.getElementById('video');
                video.play();
                video.addEventListener('play', function () {
                    this.currentTime = videoTime;//从几秒开始播放
                });
            });

        var pauseButton = document.getElementById('pauseButton');
        pauseButton.addEventListener('click', function () {
            video = document.getElementById('video');
            video.pause();
            videoTime=video.currentTime;
        });

        video.play();//加载完后自动播放
        camera.lookAt(mesh.position);
        }

    }


    //创建地平面
    function CreatePanl() {
        // var floor_1 = THREE.ImageUtils.loadTexture("textures/ground/grasslight-big.jpg");
        // floor_1.wrapS = THREE.RepeatWrapping;
        // floor_1.wrapT = THREE.RepeatWrapping;
        // floor_1.repeat.set(4, 4);
        //var floor_1Material = new THREE.MeshLambertMaterial({ map: floor_1 });
        var planeGeometry = new THREE.PlaneGeometry(300,300,100,10);
        planeMaterial = new THREE.MeshBasicMaterial({ color: 0xd6d6d6/*,map:floor_1,specular: 0xffffff, shininess: 200 */});
        plane = new THREE.Mesh(planeGeometry, planeMaterial);


        plane.receiveShadow = true;
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.x = camera.position.x;
        plane.position.y = camera.position.y-20;
        plane.position.z = camera.position.z+150;
        scene.add(plane);
    }



    // for(var _key in model){
    //     (function(key){
    //         var loader = new THREE.FBXLoader(loadingManager);
    //         loader.load( model[key].FBX, function ( object ) {//加载路径fbx文件
    //             object.traverse(function (child) {
    //             if (child.isMesh) {
    //               child.castShadow = true;
    //               child.receiveShadow = true;
    //                 }
    //             } );
    //         //scene.add( object );//模型
    //         model[key].object=object;
    //     } );
    //     })(_key)
    // }

    //加载 glTF 格式的模型
    // for(var _key in model) {
    //     (function (key) {
    //         var loader = new THREE.GLTFLoader(loadingManager);/*实例化加载器*/
    //         loader.load(model[key].gltf, function (obj) {
    //             console.log(obj);
    //             scene.add(obj.scene);
    //             console.log("运行了一个模型");
    //             meshes[key].gltfobj=obj.scene;
    //             obj.scene.position.set(0,0,50);
    //             obj.scene.scale.set(10,10,10);
    //             console.log(obj);
    //          }//, function (xhr) {
    //          //    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
    //          //}, function (error) {
    //          //    console.log('load error!' + error.getWebGLErrorMessage());
    //          //}
    //         )
    //     })(_key)
    // }

    //增强场景的真实感
    var pmremGenerator = new THREE.PMREMGenerator( renderer );
    pmremGenerator.compileEquirectangularShader();
    new THREE.RGBELoader(loadingManager)
        .setDataType( THREE.UnsignedByteType ) //hdr文件可以渲染出更加真实的场景
        .load( 'static/libs/texture/royal_esplanade_1k.hdr', function ( texture ) {

            var envMap = pmremGenerator.fromEquirectangular( texture ).texture;

            scene.background = envMap;
            scene.environment = envMap;

        } );

    var loader = new THREE.GLTFLoader(loadingManager).setPath( model.BigDataStudio.GLTF );
    loader.load( 'BigDataStudio.gltf', function ( gltf ) {
        gltf.scene.traverse( function ( child ) {
            if ( child.isMesh ) {
                // TOFIX RoughnessMipmapper seems to be broken with WebGL 2.0
                // roughnessMipmapper.generateMipmaps( child.material );
            }
        } );
        scene.add( gltf.scene );
        gltf.scene.scale.set(60,60,60);
        //gltf.scene.rotation.z=Math.PI/2;
        //gltf.scene.position(0,-100,-120);
        //roughnessMipmapper.dispose();
        //render();
    } );


    function onResourceLoaded(){
        //将模型克隆到网络中
         meshes["bigdata_room"]=model["bigdata_room"].gltfobj;
         //不知道为什么，使用这种方法，必须要有loadingManager，不然mesh为null值
         meshes["bigdata_room"].position.set(0,-15,150);
         meshes["bigdata_room"].scale.set(0.1,0.1,0.1);
         //meshes["bigdata_room"].rotation.y+=Math.PI;
         scene.add(meshes["bigdata_room"]);



        // meshes["desk"]=model.desk.mesh.clone();
        // meshes["desk"].position.set(0,-10,100);
        // meshes["desk"].scale.set(0.03,0.03,0.03);
        // scene.add(meshes["desk"]);
    }

    //camera大小随窗口变化
    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }


    animate();
    function animate(){
        //在加载资源时运行此代码
        if(Resource_Loaded==false){
            requestAnimationFrame(animate);
            loadingScreen.box.position.x-=0.05;
            renderer.setClearColor(new THREE.Color(0x55aaff));
            if(loadingScreen.box.position.x<-10)
                loadingScreen.box.position.x=10;
            loadingScreen.box.position.y=Math.sin(loadingScreen.box.position.x);
            renderer.render(loadingScreen.scene,loadingScreen.camera);
            return;
        }


        //更新鼠标控制
        //controls.update();

        renderer.setClearColor(new THREE.Color(0x55aaff));
        requestAnimationFrame(animate);
        //mesh.rotation.x += 0.01;
        //mesh.rotation.y += 0.02;
        renderer.render(scene,camera);

        if(keyboard[83]){ //敲W键
            //Math.sin/cos返回值为-1到1之间的数
            camera.position.x-=Math.sin(camera.rotation.y)*player.speed;
            camera.position.z-=Math.cos(camera.rotation.y)*player.speed;
        }

        if(keyboard[87]){ //敲s键
            camera.position.x+=Math.sin(camera.rotation.y)*player.speed;
            camera.position.z+=Math.cos(camera.rotation.y)*player.speed;
        }

        if(keyboard[65]){ //敲A键
            camera.position.x+=Math.sin(camera.rotation.y+
                Math.PI/2)*player.speed;
            camera.position.z-=Math.cos(camera.rotation.y+
                Math.PI)*player.speed;
        }

        if(keyboard[68]){ //敲D键
            camera.position.x+=Math.sin(camera.rotation.y-
                Math.PI/2)*player.speed;
            camera.position.z-=Math.cos(camera.rotation.y-
                Math.PI)*player.speed;
        }

        if(keyboard[37]){ //左箭头键
            camera.rotation.y-=player.turnSpeed;
        }

        if(keyboard[39]){ //右箭头键
            camera.rotation.y+=player.turnSpeed;
        }

        if(keyboard[38]){ //上箭头键
            camera.position.y+=player.speed;
        }

        if(keyboard[40]){ //下箭头键
            camera.position.y-=player.speed;
        }

    }

    //初始化鼠标控制
    function initControls() {

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        //设置控制器的中心点
        controls.target=new THREE.Vector3(5, 0, 0 );
        // 如果使用animate方法时，将此函数删除
        //controls.addEventListener( 'change', render );
        // 使动画循环使用时阻尼或自转 意思是否有惯性
        controls.enableDamping = true;
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        //controls.dampingFactor = 0.25;
        //是否可以缩放
        controls.enableZoom = true;
        //是否自动旋转
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        //设置相机距离原点的最远距离
        controls.minDistance = 1;
        //设置相机距离原点的最远距离
        controls.maxDistance = 2000;
        //是否开启右键拖拽
        controls.enablePan = true;
    }

    function keyDown(event){ //当按下键时触发
        keyboard[event.keyCode]=true;
    }

    function keyUp(event){ //当按键结束时触发
        keyboard[event.keyCode]=false;
    }

    // //鼠标点击事件
    // function mouseClickEvent(event){
    // 	if (!this.raycaster)
    // 		this.raycaster = new THREE.Raycaster();
    // 	if (!this.mouse)
    // 		this.mouse = new THREE.Vector2();
    //
    // 	// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
    // 	this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    // 	this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    //
    // 	// 通过摄像机和鼠标位置更新射线
    // 	this.raycaster.setFromCamera(this.mouse, this.camera);
    //
    // 	// 计算物体和射线的焦点
    // 	const intersects = this.raycaster.intersectObjects(this.scene.children,true);
    //
    // 	window.location.assign("room");
    //
    // }
    function mouseClickEvent(event){
        if (!this.raycaster)
            this.raycaster = new THREE.Raycaster();
        if (!this.mouse)
            this.mouse = new THREE.Vector2();

        // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // 通过摄像机和鼠标位置更新射线
        this.raycaster.setFromCamera(this.mouse, this.camera);

        // 计算物体和射线的焦点
        const intersects = this.raycaster.intersectObjects(this.scene.children,true);

        console.log(intersects);
        if (intersects.length !== 0){
            var video = document.getElementById('video');
            if(intersects[0].object.name === 'play'){
                video.play();

            }
            else if(intersects[0].object.name === 'pause'){
                video.pause();
            }
        }


    }
    window.addEventListener('click', mouseClickEvent);
    window.addEventListener('keydown',keyDown);
    window.addEventListener('keyup',keyUp);
    window.addEventListener('resize', onResize, false);
</script>

</body>
</html>
