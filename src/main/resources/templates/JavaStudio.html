<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
	<head>
		
		<meta charset="utf-8">
		<title>建筑</title>

<!--		<script th:src="@{static/libs/draco_decoder.js}"></script>-->
<!--		<script th:src="@{static/libs/geometry_helper.js}"></script>-->
<!--		<script th:src="@{static/libs/draco_wasm_wrapper.js}"></script>-->
<!--		<script th:src="@{static/libs/draco_decoder.wasm}"></script>-->
		<script th:src="@{static/libs/three.js}"></script>

		<script th:src="@{static/libs/GLTFLoader.js}"></script>
		<script th:src="@{static/libs/RGBELoader.js}"></script>
		<script th:src="@{static/libs/MTLLoader.js}"></script>
		<script th:src="@{static/libs/OBJLoader.js}"></script>
		<script th:src="@{static/libs/OrbitControls.js}"></script>

		<div id="overlay">
			<button id="startButton">Play</button>
		</div>

		<div id="overlay1">
			<button id="pauseButton">Pause</button>
		</div>


		<video id="video" autoplay controls><!--loop crossOrigin="anonymous" playsinline style="display:none"-->
			<source src="static/video/4.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
		</video>

	</head>
	<body>
		<script>
			//灵感1：资源文件里面有水滴的jpg，可以做一个配合现实天气的天气界面。
			//灵感2：房间贴纸分类：护眼色、经典色等。
			//灵感3：可加入"加载中"的动画
			//color:#ffffff;
		// 创建一个场景，将我们所有的元素，如物体，相机和灯光。
		
		var keyboard={}; //定义数组
		var player={height:1.8,speed:0.2,turnSpeed:Math.PI*0.01};
		
		var scene= new THREE.Scene();
		var camera= new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight,0.1, 1000);
		var renderer=new THREE.WebGLRenderer({antialias:true});//防锯齿
		renderer.setSize(window.innerWidth,window.innerHeight);
		renderer.shadowMap.enabled=true;
		renderer.shadowMap.type=THREE.BasicShadowMap;
		var plane;
		document.body.appendChild(renderer.domElement);
		var pointLight;
		var ambientLight;
		var loadingManager=null,Resource_Loaded=true;
		var loadingScreen={  //“加载中”的场景
				scene:new THREE.Scene(),
				camera:new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight,0.1,100),
				ambientLight:new THREE.AmbientLight(0xffffff,0.8),//浅蓝色
				box:new THREE.Mesh(
				        new THREE.BoxGeometry(1,1,1),
						new THREE.MeshPhongMaterial({
							color:0xff0000,
							wireframe:false
							})
							// 0xff0000 红色
							// 0x00ff00 绿色,
							// 0x0000ff 蓝色.
							// 0xffffff 白色
							// 0x000000 黑色
				)
			}
		
		//设置加载场景对象的一些属性
		loadingScreen.box.position.set(0,0,5);
		loadingScreen.camera.lookAt(loadingScreen.box.position);
		loadingScreen.scene.add(loadingScreen.box);
		loadingScreen.scene.add(loadingScreen.ambientLight);
		
		//实例化加载管理器
		loadingManager=new THREE.LoadingManager();
		//加载过程的方法一:加载过程
		loadingManager.onProgress=function(item,loaded,total){
			console.log(item,loaded,total); //console里面展示加载的项目、加载和完成
		}
		//方法二：加载完成
		loadingManager.onLoad=function(){  //必须是onLoad才行，不能是onload！！！
			console.log("已下载所有资源！");
			Resource_Loaded=true;

			//onResourceLoaded();

		}

		//模型索引
		var model= {
			JavaStudio:{
				GLTF:"static/models/gltf/Studio/JavaStudio/",
				gltfobj:null
			},
		}
		//网格索引
		var meshes={};

		init();
		function init(){
		    initLight();
			//CreatePanl();
			initControls();
			initVideo();
			//var name="static/room/computer_room.drc";
			//addModeldrc(name);
			//dracoLoad();
			//loadDrc(model['computer_room'].url);


		}




		//光源
		function initLight(){ 
		ambientLight=new THREE.AmbientLight(0xfcffbc,0.8);//浅蓝色
		pointLight=new THREE.PointLight(0x000000,0.8,1);
		pointLight.position.set(0,60,0);
		pointLight.castShadow=true;
		scene.add(ambientLight);
		scene.add(pointLight);
		}
			
		
		camera.position.x = 0;
		camera.position.y = 80;
		camera.position.z = -10;
		camera.lookAt(0,50,100);
		scene.add(camera);



		//加载视频
		initVideo();
		function initVideo() {

			//辅助工具
			var helper = new THREE.AxesHelper(50);
			//scene.add(helper);

			var play=new THREE.Mesh(
					new THREE.PlaneGeometry(10,10),
					new THREE.MeshBasicMaterial({color:0x00ff00})//绿色
			)
			play.name = 'play';
			console.log(play);
			play.position.set(120,100,240);
			play.rotation.x=Math.PI;
			scene.add(play);

			var pause=new THREE.Mesh(
					new THREE.PlaneGeometry(10,10),
					new THREE.MeshBasicMaterial({color:0xff0000})//红色
			)
			pause.name = 'pause';
			pause.position.set(120,80,240);
			pause.rotation.x=Math.PI;
			scene.add(pause);

			//添加立方体
			var geometry = new THREE.PlaneGeometry(200,150);

			//获取到video对象
			var video = document.querySelector("#video");
			//通过video对象实例化纹理
			var texture = new THREE.VideoTexture(video);
			texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;//使用平铺，因为视频尺寸不一定都是标准的
			texture.minFilter = THREE.LinearFilter;
			material = new THREE.MeshBasicMaterial( { map: texture } );
			var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh

			mesh.rotation.y=Math.PI;
			mesh.position.set(0,50,245);
			scene.add(mesh);
            //移除video标签的显示
			document.getElementById('video').style.display = 'none';

			var videoTime=0;
			window.onload=function() { //等所有都加载完了再执行function后面的
				var startButton = document.getElementById('startButton');
				startButton.addEventListener('click', function () {
					video = document.getElementById('video');
					video.play();
					video.addEventListener('play', function () {
						this.currentTime = videoTime;//从几秒开始播放
					});
				});


				var pauseButton = document.getElementById('pauseButton');
				pauseButton.addEventListener('click', function () {
					video = document.getElementById('video');
					video.pause();
					videoTime=video.currentTime;
				});

				video.play();//加载完后自动播放
				requestAnimationFrame(animate);
				renderer.render(scene,camera);

			}

		}


		//创建地平面
		function CreatePanl() {
		            // var floor_1 = THREE.ImageUtils.loadTexture("textures/ground/grasslight-big.jpg");
		            // floor_1.wrapS = THREE.RepeatWrapping;
		            // floor_1.wrapT = THREE.RepeatWrapping;
		            // floor_1.repeat.set(4, 4);
		            //var floor_1Material = new THREE.MeshLambertMaterial({ map: floor_1 });
		            var planeGeometry = new THREE.PlaneGeometry(300,300,100,10);
		            planeMaterial = new THREE.MeshBasicMaterial({ color: 0xd6d6d6/*,map:floor_1,specular: 0xffffff, shininess: 200 */});
		            plane = new THREE.Mesh(planeGeometry, planeMaterial);
		          
					
					plane.receiveShadow = true;
		            plane.rotation.x = -0.5 * Math.PI;
		            plane.position.x = camera.position.x;
		            plane.position.y = camera.position.y-20;
		            plane.position.z = camera.position.z+150;
		            scene.add(plane);
		}


			var pmremGenerator = new THREE.PMREMGenerator( renderer );
			pmremGenerator.compileEquirectangularShader();
			new THREE.RGBELoader(loadingManager)
					.setDataType( THREE.UnsignedByteType ) //hdr文件可以渲染出更加真实的场景
					.load( 'static/libs/texture/royal_esplanade_1k.hdr', function ( texture ) {

						var envMap = pmremGenerator.fromEquirectangular( texture ).texture;

						scene.background = envMap;
						scene.environment = envMap;

					} );

			var loader = new THREE.GLTFLoader(loadingManager).setPath( model.JavaStudio.GLTF );
			loader.load( 'JavaStudio.gltf', function ( gltf ) {
				gltf.scene.traverse( function ( child ) {
					if ( child.isMesh ) {
						// TOFIX RoughnessMipmapper seems to be broken with WebGL 2.0
						// roughnessMipmapper.generateMipmaps( child.material );
					}
				} );
				scene.add( gltf.scene );
				gltf.scene.scale.set(60,60,60);
				//gltf.scene.rotation.z=Math.PI/2;
				//gltf.scene.position(0,-100,-120);
				//roughnessMipmapper.dispose();
				//render();
			} );

			var pmremGenerator = new THREE.PMREMGenerator( renderer );
			pmremGenerator.compileEquirectangularShader();
			new THREE.RGBELoader(loadingManager)
					.setDataType( THREE.UnsignedByteType ) //hdr文件可以渲染出更加真实的场景
					.load( 'static/libs/texture/royal_esplanade_1k.hdr', function ( texture ) {

						var envMap = pmremGenerator.fromEquirectangular( texture ).texture;

						scene.background = envMap;
						scene.environment = envMap;

					} );

			var loader = new THREE.GLTFLoader(loadingManager).setPath( "static/models/gltf/Studio/JavaStudio/" );
			loader.load( 'BigDataStudio.gltf', function ( gltf ) {
				gltf.scene.traverse( function ( child ) {
					if ( child.isMesh ) {
						// TOFIX RoughnessMipmapper seems to be broken with WebGL 2.0
						// roughnessMipmapper.generateMipmaps( child.material );
					}
				} );
				scene.add( gltf.scene );
				gltf.scene.scale.set(60,60,60);
				//gltf.scene.rotation.z=Math.PI/2;
				//gltf.scene.position(0,-100,-120);
				//roughnessMipmapper.dispose();
				//render();
			} );






				function onResourceLoaded(){
			//将模型克隆到网络中
			meshes["computer_room"]=model.room_profile.mesh.clone();
			//不知道为什么，使用这种方法，必须要有loadingManager，不然mesh为null值
			meshes["computer_room"].position.set(0,-15,150);
			meshes["computer_room"].scale.set(0.05,0.05,0.05);
			//meshes["computer_room"].rotation.y+=Math.PI/2;
			scene.add(meshes["computer_room"]);

		}

		//camera大小随窗口变化
		function onResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}
		
		
		animate();
		function animate(){
			//在加载资源时运行此代码
			if(Resource_Loaded==false){
				requestAnimationFrame(animate);
				loadingScreen.box.position.x-=0.05;
				renderer.setClearColor(new THREE.Color(0x55aaff));
				if(loadingScreen.box.position.x<-10)
				loadingScreen.box.position.x=10;
				loadingScreen.box.position.y=Math.sin(loadingScreen.box.position.x);
				renderer.render(loadingScreen.scene,loadingScreen.camera);
				return;
			}

			//更新鼠标控制
			controls.update();

			renderer.setClearColor(new THREE.Color(0x55aaff));
		   	requestAnimationFrame(animate);
			  //mesh.rotation.x += 0.01;
			  //mesh.rotation.y += 0.02;
		   	renderer.render(scene,camera);
			
			if(keyboard[83]){ //敲W键
								   //Math.sin/cos返回值为-1到1之间的数
								   camera.position.x-=Math.sin(camera.rotation.y)*player.speed;
			    camera.position.z-=Math.cos(camera.rotation.y)*player.speed;
			}
			
			if(keyboard[87]){ //敲s键
					camera.position.x+=Math.sin(camera.rotation.y)*player.speed;
			     camera.position.z+=Math.cos(camera.rotation.y)*player.speed;
			}
			
			if(keyboard[65]){ //敲A键
					camera.position.x+=Math.sin(camera.rotation.y+
									                   Math.PI/2)*player.speed;
			     camera.position.z-=Math.cos(camera.rotation.y+
									                   Math.PI)*player.speed;
			}
			
			if(keyboard[68]){ //敲D键
					camera.position.x+=Math.sin(camera.rotation.y-
									   Math.PI/2)*player.speed;
			     camera.position.z-=Math.cos(camera.rotation.y-
									   Math.PI)*player.speed;
								}
								
			 if(keyboard[37]){ //左箭头键
				camera.rotation.y-=player.turnSpeed;
							}
								
			if(keyboard[39]){ //右箭头键
				camera.rotation.y+=player.turnSpeed;
							}
			
			if(keyboard[38]){ //上箭头键
				camera.position.y+=player.speed;
							}
								
			if(keyboard[40]){ //下箭头键
				camera.position.y-=player.speed;
							}

		   }

			//初始化鼠标控制
			function initControls() {

				controls = new THREE.OrbitControls(camera, renderer.domElement);
				//设置控制器的中心点
				//controls.target.set( 0, 5, 0 );
				// 如果使用animate方法时，将此函数删除
				//controls.addEventListener( 'change', render );
				// 使动画循环使用时阻尼或自转 意思是否有惯性
				controls.enableDamping = true;
				//动态阻尼系数 就是鼠标拖拽旋转灵敏度
				//controls.dampingFactor = 0.25;
				//是否可以缩放
				controls.enableZoom = true;
				//是否自动旋转
				controls.autoRotate = false;
				controls.autoRotateSpeed = 0.5;
				//设置相机距离原点的最远距离
				controls.minDistance = 1;
				//设置相机距离原点的最远距离
				controls.maxDistance = 2000;
				//是否开启右键拖拽
				controls.enablePan = true;
			}

		   function keyDown(event){ //当按下键时触发
		   	keyboard[event.keyCode]=true;
		   }
		   
		   function keyUp(event){ //当按键结束时触发
		   	keyboard[event.keyCode]=false;
		   }

			// //鼠标点击事件
			// function mouseClickEvent(event){
			// 	if (!this.raycaster)
			// 		this.raycaster = new THREE.Raycaster();
			// 	if (!this.mouse)
			// 		this.mouse = new THREE.Vector2();
			//
			// 	// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
			// 	this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			// 	this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			//
			// 	// 通过摄像机和鼠标位置更新射线
			// 	this.raycaster.setFromCamera(this.mouse, this.camera);
			//
			// 	// 计算物体和射线的焦点
			// 	const intersects = this.raycaster.intersectObjects(this.scene.children,true);
			//
			// 	window.location.assign("room");
			//
			// }
			function mouseClickEvent(event){
				if (!this.raycaster)
					this.raycaster = new THREE.Raycaster();
				if (!this.mouse)
					this.mouse = new THREE.Vector2();

				// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
				this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

				// 通过摄像机和鼠标位置更新射线
				this.raycaster.setFromCamera(this.mouse, this.camera);

				// 计算物体和射线的焦点
				const intersects = this.raycaster.intersectObjects(this.scene.children,true);

				console.log(intersects);
				if (intersects.length !== 0){
					var video = document.getElementById('video');
					if(intersects[0].object.name === 'play'){
						video.play();

					}
					else if(intersects[0].object.name === 'pause'){
						video.pause();
					}
				}

				//window.location.assign("room1");


			}
			window.addEventListener('click', mouseClickEvent);
		   window.addEventListener('keydown',keyDown);
		   window.addEventListener('keyup',keyUp);
		   window.addEventListener('resize', onResize, false);
		</script>
	</body>
</html>
