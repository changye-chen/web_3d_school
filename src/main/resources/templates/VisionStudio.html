<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>

    <meta charset="utf-8">
    <title>建筑</title>

    <script type="text/javascript" th:src="@{static/libs/three.js}"></script>
    <script type="text/javascript" th:src="@{static/libs/GLTFLoader.js}"></script>
    <script type="text/javascript" th:src="@{static/libs/RGBELoader.js}"></script>
    <script type="text/javascript" th:src="@{static/libs/DRACOLoader.js}"></script>
    <script type="text/javascript" th:src="@{static/libs/OrbitControls.js}"></script>
    <script type="text/javascript" th:src="@{static/libs/stats.js}"></script>

    <script type="text/javascript" th:src="@{static/libs/prefixfree.min.js}"></script>
    <script type="text/javascript" th:src="@{static/libs/modernizr.js}"></script>
    <style type="text/css" th:src="@{static/css/progress.css}"> @import "static/css/progress.css";</style>

    <div id="wrapper">
        <div class="loader-container">
            <div class="meter">0</div>
            <span class="runner"></span>
        </div>
    </div>

    <div id="overlay" style="display:none">
        <button id="startButton">Play</button>
    </div>

    <div id="overlay1" style="display:none">
        <button id="pauseButton">Pause</button>
    </div>


    <video id="video" autoplay controls><!--loop crossOrigin="anonymous" playsinline style="display:none"-->
        <source src="static/video/4.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
    </video>

</head>
<script>
    //灵感1：资源文件里面有水滴的jpg，可以做一个配合现实天气的天气界面。
    //灵感2：房间贴纸分类：护眼色、经典色等。
    //灵感3：可加入"加载中"的动画
    //color:#ffffff;
    // 创建一个场景，将我们所有的元素，如物体，相机和灯光。

    var keyboard={}; //定义数组
    var player={height:1.8,speed:2,turnSpeed:Math.PI*0.01};
    var control;
    var stats;
    var progress;

    var scene= new THREE.Scene();
    var camera= new THREE.PerspectiveCamera(60,window.innerWidth / window.innerHeight,1, 400);
    var renderer=new THREE.WebGLRenderer({antialias:true});//防锯齿
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.shadowMap.enabled=true;
    renderer.shadowMap.type=THREE.BasicShadowMap;
    renderer.setClearColor(new THREE.Color(0x55aaff));

    //场景美化效果
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    var hdrPath='static/libs/texture/royal_esplanade_1k.hdr';
    var gltfPath='static/models/gltf/Studio/VisionStudio/VisionStudio.gltf';

    //document.body.appendChild(renderer.domElement);
    var loadingManager=null,Resource_Loaded=true;
    var loadingScreen={  //“加载中”的场景
        scene:new THREE.Scene(),
        camera:new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight,0.1,100),
        ambientLight:new THREE.AmbientLight(0xffffff,0.8),//浅蓝色
        box:new THREE.Mesh(
            new THREE.BoxBufferGeometry(1,1,1),
            new THREE.MeshPhongMaterial({
                color:0xff0000,
                wireframe:false
            })
        )
    }

    //设置加载场景对象的一些属性
    loadingScreen.box.position.set(0,0,5);
    loadingScreen.camera.lookAt(loadingScreen.box.position);
    loadingScreen.scene.add(loadingScreen.box);
    loadingScreen.scene.add(loadingScreen.ambientLight);

    //实例化加载管理器
    loadingManager=new THREE.LoadingManager();
    //加载过程的方法一:加载过程
    loadingManager.onProgress=function(item,loaded,total){
        //console.log(item,loaded,total); //console里面展示加载的项目、加载和完成
        progress=(loaded / total * 100).toFixed(0);
        console.log('加载完成的百分比' + progress + '%');
        progressBar(progress);
    }
    //方法二：加载完成
    loadingManager.onLoad=function(){  //必须是onLoad才行，不能是onload！！！
        console.log("已下载所有资源！");  //没有加载完资源
        Resource_Loaded=true;
        document.body.appendChild(renderer.domElement);
        document.getElementById('wrapper').style.display = 'none';
        animate();
        // onResourceLoaded(); //记得给所有loader加上（loadingManager）
    }

    //模型索引
    var model= {
        BigDataStudio:{
            GLTF:"static/models/gltf/Studio/BigDataStudio-1/BigDataStudio.gltf",
            gltfobj:null
        }
    }
    //网格索引
    var meshes={};


    //光源
    function initLight(){
        ambientLight=new THREE.AmbientLight(0xfffffff,0.5);//浅蓝色
        pointLight=new THREE.PointLight(0xfffffff,0.8,0.5);
        pointLight.position.set(0,0,0);
        pointLight.castShadow=true;
        scene.add(ambientLight);
        scene.add(pointLight);
    }

    function deskView() {
        camera.position.x = -10;
        camera.position.y = 85;
        camera.position.z = -155;
        camera.lookAt(-10, 70, 95);
        scene.add(camera);
    }

    function screenView() {
        camera.position.x = -10;
        camera.position.y = 100;
        camera.position.z = -85;
        camera.lookAt(-10, 80, 95);
        scene.add(camera);
    }

    init(-20,0,0);
    function init(x,y,z) {
        //加载两个小屏幕
        initVideo(55, 80, 90+x, 124+y, 96+z, "video");
        initVideo(55, 80, 90+x, 42+y, 96+z, "video");
        //initControls();
        //加载主屏幕及控制按钮
        initVideo(200,150,-38.5+x,77+y,96+z,"video");
        mainVideoControl(-115+x,158+y,96+z,-130+x,158+y,96+z,"video");
        //加载性能插件
        initStats();
        //默认桌子视角
        deskView();
        loadGLTF(hdrPath,gltfPath,70,70,70);

        //加一块黑幕在屏幕后面
        var darkMesh=new THREE.Mesh(
            new THREE.PlaneBufferGeometry(260,165),
            new THREE.MeshBasicMaterial({color:0x00000f})
        )
        darkMesh.position.set(-11+x,82+y,97+z);
        darkMesh.rotation.x=Math.PI;
        scene.add(darkMesh);
    }

    function progressBar(progress){
        var Loader = function () {
            var loader = document.querySelector('.loader-container'),
                meter = document.querySelector('.meter'),
                k, i = 1,
                counter = function () {
                    if (i <= 1) {
                        meter.innerHTML =progress;//i.toString();
                        i++;
                    } else {
                        window.clearInterval(k);
                    }
                };
            return {
                init: function (options) {
                    options = options || {};
                    var time = options.time ? options.time : 0,interval = time/20;
                    loader.classList.add('run');
                    k = window.setInterval(counter, interval);
                    setTimeout(function () {
                        loader.classList.add('done');
                    }, time);
                },
            }
        }();
        Loader.init({
            // If you have changed the @time in LESS, update this number to the corresponding value. Measured in miliseconds.
            time: 100
        });
    }

    //加载视频
    function initVideo(width,height,x,y,z,videoTag) {
        //添加立方体
        var geometry = new THREE.PlaneBufferGeometry(width,height);

        //获取到video对象
        var video = document.querySelector("#"+videoTag);

        //通过video对象实例化纹理
        var texture = new THREE.VideoTexture(video);
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;//使用平铺，因为视频尺寸不一定都是标准的
        texture.minFilter = THREE.LinearFilter;
        material = new THREE.MeshBasicMaterial( { map: texture } );
        var mainScreen = new THREE.Mesh(geometry, material); //网格模型对象Mesh

        mainScreen.rotation.y=Math.PI;
        mainScreen.position.set(x,y,z);
        scene.add(mainScreen);
        //移除video标签的显示
        document.getElementById('video').style.display = 'none';
    }

    function mainVideoControl(playx,playy,playz,pausex,pausey,pausez,videoTag){
        //辅助工具
        var helper = new THREE.AxesHelper(50);
        //scene.add(helper);

        var playTexture = new THREE.ImageUtils.loadTexture("static/textures/start.jpg",function(){
        });
        var play=new THREE.Mesh(
            new THREE.PlaneBufferGeometry(10,10),
            new THREE.MeshBasicMaterial({
                map:playTexture
                //color:0x00ff00
            })
        )
        play.name = 'play';
        console.log(play);
        play.position.set(playx,playy,playz);
        play.rotation.x=Math.PI;
        play.rotation.z=Math.PI;
        scene.add(play);

        var pauseTexture = new THREE.ImageUtils.loadTexture("static/textures/pause.jpg",function(){
        });
        var pause=new THREE.Mesh(
            new THREE.PlaneBufferGeometry(10,10),
            new THREE.MeshBasicMaterial({
                map:pauseTexture
                //color:0xff0000
            })
        )
        pause.name = 'pause';
        pause.position.set(pausex,pausey,pausez);
        pause.rotation.x=Math.PI;
        scene.add(pause);

        var videoTime=0;
        //window.onload=function() { //等所有都加载完了再执行function后面的
        var startButton = document.getElementById('startButton');
        startButton.addEventListener('click', function () {
            video = document.getElementById(videoTag);
            video.play();
            video.addEventListener('play', function () {
                this.currentTime = videoTime;//从几秒开始播放
            });
        });

        var pauseButton = document.getElementById('pauseButton');
        pauseButton.addEventListener('click', function () {
            video = document.getElementById(videoTag);
            video.pause();
            videoTime = video.currentTime;
        });
        video.play();//加载完后自动播放
    }


    function loadGLTF(hdrPath,gltfPath,scalex, scaley, scalez) {
        //增强场景的真实感
        var pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        new THREE.RGBELoader(loadingManager)
            .setDataType(THREE.UnsignedByteType) //hdr文件可以渲染出更加真实的场景
            .load(hdrPath, function (texture) {
                var envMap = pmremGenerator.fromEquirectangular(texture).texture;
                scene.background = envMap;
                scene.environment = envMap;

            });

        var loader = new THREE.GLTFLoader(loadingManager);
        loader.load(gltfPath, function (gltf) {
            gltf.scene.traverse(function (child) {
                if (child.isMesh) {
                    // TOFIX RoughnessMipmapper seems to be broken with WebGL 2.0
                    // roughnessMipmapper.generateMipmaps( child.material );
                }
            });
            console.log(gltf.scene);
            //去掉多余白色正方体
            gltf.scene.children.forEach(object => {
                if (object.name === 'Cube')
                    gltf.scene.remove(object);
            })
            scene.add(gltf.scene);
            gltf.scene.scale.set(scalex, scaley, scalez);
            //gltf.scene.rotation.z=Math.PI/2;
            //gltf.scene.position(0,-100,-120);
            //roughnessMipmapper.dispose();
            //render();
        });

        // var loader = new THREE.GLTFLoader(loadingManager);//path =  'three/model/jifangDraco.gltf' ;
        // var dracoLoader = new THREE.DRACOLoader();
        // //dracoLoader.setDecoderPath( 'three/js/libs/draco/gltf/' );
        // loader.setDRACOLoader( dracoLoader );
        // loader.load(gltfPath,function (gltf) {
        //     gltf.scene.traverse(function (child) {
        //         if (child.isMesh) {
        //             // TOFIX RoughnessMipmapper seems to be broken with WebGL 2.0
        //             // roughnessMipmapper.generateMipmaps( child.material );
        //         }
        //     });
        //     scene.add(gltf.scene);
        //     gltf.scene.scale.set(scalex, scaley, scalez);
        // });

    }

    function initStats() {

        stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms
        // 放在左上角
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        document.body.appendChild(stats.domElement);
        return stats;
    }

    function onResourceLoaded(){
        //将模型克隆到网络中
         meshes["bigdata_room"]=model["bigdata_room"].gltfobj;
         //不知道为什么，使用这种方法，必须要有loadingManager，不然mesh为null值
         meshes["bigdata_room"].position.set(0,-15,150);
         meshes["bigdata_room"].scale.set(0.1,0.1,0.1);
         //meshes["bigdata_room"].rotation.y+=Math.PI;
         scene.add(meshes["bigdata_room"]);



        // meshes["desk"]=model.desk.mesh.clone();
        // meshes["desk"].position.set(0,-10,100);
        // meshes["desk"].scale.set(0.03,0.03,0.03);
        // scene.add(meshes["desk"]);
    }

    //camera大小随窗口变化
    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }


    //animate();
    function animate(){

        //更新鼠标控制
        //controls.update();
        stats.update();

        requestAnimationFrame(animate);
        //mesh.rotation.x += 0.01;
        //mesh.rotation.y += 0.02;
        renderer.render(scene,camera);

        if(keyboard[49]) { //敲1键
            deskView();
        }
        if(keyboard[50]) { //敲1键
            screenView();
        }

        if(keyboard[83]){ //敲W键
            //Math.sin/cos返回值为-1到1之间的数
            camera.position.x-=Math.sin(camera.rotation.y)*player.speed;
            camera.position.z-=Math.cos(camera.rotation.y)*player.speed;
        }

        if(keyboard[87]){ //敲s键
            camera.position.x+=Math.sin(camera.rotation.y)*player.speed;
            camera.position.z+=Math.cos(camera.rotation.y)*player.speed;
        }

        if(keyboard[65]){ //敲A键
            camera.position.x+=Math.sin(camera.rotation.y+
                Math.PI/2)*player.speed;
            camera.position.z-=Math.cos(camera.rotation.y+
                Math.PI)*player.speed;
        }

        if(keyboard[68]){ //敲D键
            camera.position.x+=Math.sin(camera.rotation.y-
                Math.PI/2)*player.speed;
            camera.position.z-=Math.cos(camera.rotation.y-
                Math.PI)*player.speed;
        }

        if(keyboard[37]){ //左箭头键
            camera.rotation.y-=player.turnSpeed;
        }

        if(keyboard[39]){ //右箭头键
            camera.rotation.y+=player.turnSpeed;
        }

        if(keyboard[38]){ //上箭头键
            camera.position.y+=player.speed;
        }

        if(keyboard[40]){ //下箭头键
            camera.position.y-=player.speed;
        }

    }

    //初始化鼠标控制
    function initControls() {

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        //设置控制器的中心点
        controls.target=new THREE.Vector3(5, 0, 0 );
        // 如果使用animate方法时，将此函数删除
        //controls.addEventListener( 'change', render );
        // 使动画循环使用时阻尼或自转 意思是否有惯性
        controls.enableDamping = true;
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        //controls.dampingFactor = 0.25;
        //是否可以缩放
        controls.enableZoom = true;
        //是否自动旋转
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;
        //设置相机距离原点的最远距离
        controls.minDistance = 1;
        //设置相机距离原点的最远距离
        controls.maxDistance = 2000;
        //是否开启右键拖拽
        controls.enablePan = true;
    }

    function keyDown(event){ //当按下键时触发
        keyboard[event.keyCode]=true;
    }

    function keyUp(event){ //当按键结束时触发
        keyboard[event.keyCode]=false;
    }

    // //鼠标点击事件
    // function mouseClickEvent(event){
    // 	if (!this.raycaster)
    // 		this.raycaster = new THREE.Raycaster();
    // 	if (!this.mouse)
    // 		this.mouse = new THREE.Vector2();
    //
    // 	// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
    // 	this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    // 	this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    //
    // 	// 通过摄像机和鼠标位置更新射线
    // 	this.raycaster.setFromCamera(this.mouse, this.camera);
    //
    // 	// 计算物体和射线的焦点
    // 	const intersects = this.raycaster.intersectObjects(this.scene.children,true);
    //
    // 	window.location.assign("room");
    //
    // }
    function mouseClickEvent(event){
        if (!this.raycaster)
            this.raycaster = new THREE.Raycaster();
        if (!this.mouse)
            this.mouse = new THREE.Vector2();

        // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // 通过摄像机和鼠标位置更新射线
        this.raycaster.setFromCamera(this.mouse, this.camera);

        // 计算物体和射线的焦点
        const intersects = this.raycaster.intersectObjects(this.scene.children,true);

        console.log(intersects);
        if (intersects.length !== 0){
            var video = document.getElementById('video');
            if(intersects[0].object.name === 'play'){
                video.play();

            }
            else if(intersects[0].object.name === 'pause'){
                video.pause();
            }
        }


    }
    window.addEventListener('click', mouseClickEvent);
    window.addEventListener('keydown',keyDown);
    window.addEventListener('keyup',keyUp);
    window.addEventListener('resize', onResize, false);
</script>

</body>
</html>
