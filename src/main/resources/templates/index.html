<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>china-3D</title>
  <style>
    html body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #provinceInfo {
      position: absolute;
      z-index: 2;
      background: white;
      padding: 10px;
      visibility: hidden;
    }
  </style>
  <script type="text/javascript" th:src="@{/static/js/three.js}"></script>
  <script type="text/javascript" th:src="@{/static/js/OrbitControls.js}"></script>
  <script type="text/javascript" th:src="@{/static/js/d3-array.v1.min.js}"></script>
  <script type="text/javascript" th:src="@{/static/js/d3-geo.v1.min.js}"></script>
</head>
<body>
  <a th:href="@{/user/login}">登录</a>
  <a th:href="@{/user/logout}">注销</a>


  <div id="provinceInfo"></div>
  
</body>
<script>
  class lineMap {
    constructor(container) {
      this.container = container ? container : document.body;
    }

    init() {
      this.provinceInfo = document.getElementById('provinceInfo');
      // 渲染器
      this.renderer = new THREE.WebGLRenderer();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.container.appendChild(this.renderer.domElement);

      // 场景
      this.scene = new THREE.Scene();

      // 相机 透视相机
      this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      this.camera.position.set(0, -70, 150);
      this.camera.lookAt(0, 0, 0);

      this.setController(); // 设置控制

      this.setLight(); // 设置灯光

      //this.setRaycaster();

      this.animate();

      // this.loadFont(); // 加载字体
      
      this.loadMapData();

      this.setResize(); // 绑定浏览器缩放事件
	  
	  //
	  document.body.addEventListener('mousemove', this.mouseMoveEvent.bind(this));
	  document.body.addEventListener('click', this.mouseClickEvent.bind(this));
    }

    setResize() {
      let _this = this;
      window.addEventListener('resize', function () {
        _this.renderer.setSize(window.innerWidth, window.innerHeight);
      })
    }

    loadMapData() {
      let _this = this;

      // 加载json文件
      let loader = new THREE.FileLoader();
      loader.load('static/json/china.json', function (data) {
        let jsonData = JSON.parse(data);
        _this.initMap(jsonData);
      });
    }

    loadFont() { //加载中文字体
      var loader = new THREE.FontLoader();
      var _this = this;
      loader.load('fonts/chinese.json', function (response) {
        _this.font = response;
        _this.loadMapData();
      });

    }

    createText(text, position) {
      var shapes = this.font.generateShapes(text, 1);

      var geometry = new THREE.ShapeBufferGeometry(shapes);

      var material = new THREE.MeshBasicMaterial();

      var textMesh = new THREE.Mesh(geometry, material);
      textMesh.position.set(position.x, position.y, position.z);

      this.scene.add(textMesh);
    }

    initMap(chinaJson) {
      // 建一个空对象存放对象
      this.map = new THREE.Object3D();

      let _this = this;

      // 墨卡托投影转换
      const projection = d3.geoMercator().center([104.0, 37.5]).scale(80).translate([0, 0]);

      chinaJson.features.forEach(elem => {
        // 定一个省份3D对象
        const province = new THREE.Object3D();
        // 每个的 坐标 数组
        const coordinates = elem.geometry.coordinates;
        // 循环坐标数组
        coordinates.forEach(multiPolygon => {

          multiPolygon.forEach(polygon => {
            const shape = new THREE.Shape();
            const lineMaterial = new THREE.LineBasicMaterial({
              color: 'white',
              opacity: 0.6
            });
            const lineGeometry = new THREE.Geometry();

            for (let i = 0; i < polygon.length; i++) {
              const [x, y] = projection(polygon[i]);
              if (i === 0) {
                shape.moveTo(x, -y);
              }
              shape.lineTo(x, -y);
              lineGeometry.vertices.push(new THREE.Vector3(x, -y, 4.01));
            }

            const extrudeSettings = {
              depth: 4,
              bevelEnabled: false
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const material = new THREE.MeshBasicMaterial({
              color: '#02a1e2',
              transparent: true,
              opacity: 0.6
            });
            const material1 = new THREE.MeshBasicMaterial({
              color: '#3480C4',
              transparent: true,
              opacity: 0.5
            });
            /* const material = new THREE.MeshBasicMaterial({ color: '#dedede', transparent: false, opacity: 0.6 });
            const material1 = new THREE.MeshBasicMaterial({ color: '#dedede', transparent: false, opacity: 0.5 }); */
            const mesh = new THREE.Mesh(geometry, [material, material1]);
            const line = new THREE.Line(lineGeometry, lineMaterial);
            province.add(mesh);
            province.add(line)

          })

        })

        // 将geo的属性放到省份模型中
        province.properties = elem.properties;
        if (elem.properties.contorid) {
          const [x, y] = projection(elem.properties.contorid);
          province.properties._centroid = [x, y];
        }

        //绘制光柱
        if(province.properties.center){
          const texture = new THREE.TextureLoader().load("static/images/lightray_yellow.jpg");

          const [x, y] = projection(province.properties.center);
          const planegeomentry = new THREE.PlaneGeometry(1, 10);
          var planematerial = new THREE.MeshBasicMaterial({
            //map: texture,
            map: texture, ////颜色贴图
            color: '#ffff00',
            transparent: true,
            opacity: 0.7,
            depthTest: false, //深度测试属性
            blending: THREE.AdditiveBlending, //滤镜选择
            side: THREE.DoubleSide
          })
          var plane = new THREE.Mesh(planegeomentry, planematerial);
          plane.position.set(x, -y, 8);
          plane.rotation.x = Math.PI / 2;
          province.add(plane);
          var plane2 = plane.clone();
          plane2.rotation.y = Math.PI / 2;
          province.add(plane2);
        }


        _this.map.add(province);

      })

      this.scene.add(this.map);
    }

	//鼠标移动事件
    mouseMoveEvent(event) {
		this.eventOffset = {};
	    if (!this.raycaster)
			this.raycaster = new THREE.Raycaster();
		if (!this.mouse)
			this.mouse = new THREE.Vector2();

		// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
		this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;


        this.eventOffset.x = event.clientX;
        this.eventOffset.y = event.clientY;
        this.provinceInfo.style.left = this.eventOffset.x + 2 + 'px';
        this.provinceInfo.style.top = this.eventOffset.y + 2 + 'px';
		
		// 通过摄像机和鼠标位置更新射线
		this.raycaster.setFromCamera(this.mouse, this.camera);

		// 计算物体和射线的焦点
		const intersects = this.raycaster.intersectObjects(this.scene.children, true);
		
		if (this.activeInstersect && this.activeInstersect.length > 0) { // 将上一次选中的恢复颜色
		  this.activeInstersect.forEach(element => {
		    element.object.material[0].color.set('#02A1E2');
		    element.object.material[1].color.set('#3480C4');
		  });
		}
		
		this.activeInstersect = []; // 设置为空
		
		for (var i = 0; i < intersects.length; i++) {
			if (intersects[i].object.material && intersects[i].object.material.length === 2) {
			    this.activeInstersect.push(intersects[i]);
			    intersects[i].object.material[0].color.set(0xff0000);
			    intersects[i].object.material[1].color.set(0xff0000);
			    break; // 只取第一个
			   }
		}
		
		//显示省份信息
		this.createProvinceInfo();

    }
	
	//鼠标点击事件
	mouseClickEvent(event){
		if (!this.raycaster)
		    this.raycaster = new THREE.Raycaster();
		if (!this.mouse)
		    this.mouse = new THREE.Vector2();
		
		// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
		this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
		
		// 通过摄像机和鼠标位置更新射线
		this.raycaster.setFromCamera(this.mouse, this.camera);
		
		// 计算物体和射线的焦点
		const intersects = this.raycaster.intersectObjects(this.scene.children,true);
		if (intersects.length !== 0 && intersects[0].object.parent.properties.name) {
		  var properties = intersects[0].object.parent.properties;
		  if(properties.name === '辽宁省'){
			  window.location.assign("building");
			 }
		}
	
	}

    setLight() {
      let ambientLight = new THREE.AmbientLight(0xffffff); // 环境光
      this.scene.add(ambientLight);
    }

    setController() {
      this.controller = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      /* this.controller.enablePan = false; // 禁止右键拖拽

      this.controller.enableZoom = true; // false-禁止右键缩放
      
      this.controller.maxDistance = 200; // 最大缩放 适用于 PerspectiveCamera
      this.controller.minDistance = 50; // 最大缩放

      this.controller.enableRotate = true; // false-禁止旋转 */

      /* this.controller.minZoom = 0.5; // 最小缩放 适用于OrthographicCamera
      this.controller.maxZoom = 2; // 最大缩放 */

    }

    animate() {
      requestAnimationFrame(this.animate.bind(this));

      this.renderer.render(this.scene, this.camera);
    }

    createProvinceInfo() { // 显示省份的信息      
      if (this.activeInstersect.length !== 0 && this.activeInstersect[0].object.parent.properties.name) {
        var properties = this.activeInstersect[0].object.parent.properties;

        this.provinceInfo.textContent = properties.name;

        this.provinceInfo.style.visibility = 'visible';
      } else {
        this.provinceInfo.style.visibility = 'hidden';
      }


    }
  }
</script>
<script>
  let line = new lineMap();
  line.init();
</script>

</html>