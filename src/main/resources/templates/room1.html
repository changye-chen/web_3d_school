<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
	<head>
		
		<meta charset="utf-8">
		<title>建筑</title>
		<script th:src="@{static/libs/three.js}"></script>
		<script th:src="@{static/libs/MTLLoader.js}"></script>
		<script th:src="@{static/libs/OBJLoader.js}"></script>
	</head>
	<body>
		<script>
			//灵感1：资源文件里面有水滴的jpg，可以做一个配合现实天气的天气界面。
			//灵感2：房间贴纸分类：护眼色、经典色等。
			//灵感3：可加入"加载中"的动画
			//color:#ffffff;
		// 创建一个场景，将我们所有的元素，如物体，相机和灯光。
		
		var keyboard={}; //定义数组
		var player={height:1.8,speed:0.2,turnSpeed:Math.PI*0.01};
		
		var scene= new THREE.Scene();
		var camera= new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight,0.1, 1000);
		var renderer=new THREE.WebGLRenderer({antialias:true});//防锯齿
		renderer.setSize(window.innerWidth,window.innerHeight);
		renderer.shadowMap.enabled=true;
		renderer.shadowMap.type=THREE.BasicShadowMap;
		var plane;
		document.body.appendChild(renderer.domElement);
		var pointLight;
		var ambientLight;
		var loadingManager=null,Resource_Loaded=false;
		var loadingScreen={  //“加载中”的场景
				scene:new THREE.Scene(),
				camera:new THREE.PerspectiveCamera(90,window.innerWidth / window.innerHeight,0.1,100),
				ambientLight:new THREE.AmbientLight(0xffffff,0.8),//浅蓝色
				box:new THREE.Mesh(
				        new THREE.BoxGeometry(1,1,1),
						new THREE.MeshPhongMaterial({
							color:0xff0000,
							wireframe:false
							})
							// 0xff0000 红色
							// 0x00ff00 绿色,
							// 0x0000ff 蓝色.
							// 0xffffff 白色
							// 0x000000 黑色
				)
			}
		
		//设置加载场景对象的一些属性
		loadingScreen.box.position.set(0,0,5);
		loadingScreen.camera.lookAt(loadingScreen.box.position);
		loadingScreen.scene.add(loadingScreen.box);
		loadingScreen.scene.add(loadingScreen.ambientLight);
		
		//实例化加载管理器
		loadingManager=new THREE.LoadingManager();
		//加载过程的方法一:加载过程
		loadingManager.onProgress=function(item,loaded,total){
			console.log(item,loaded,total); //console里面展示加载的项目、加载和完成
		}
		//方法二：加载完成
		loadingManager.onLoad=function(){  //必须是onLoad才行，不能是onload！！！
			console.log("已下载所有资源！");
			Resource_Loaded=true;
			onResourceLoaded();
		}
		
		
		
		//模型索引  
		var models={
			school:{
				obj:"static/room2/School.obj",
				mtl:"static/room2/School.mtl",
				mesh:null,
				receiveShadow:true,
				castShadow:true,
			},
		// 	Garen:{    
		// 	 	obj:"Shool/Garen.obj",
		// 	 	mtl:"Shool/Garen_base_TX_CM.mtl",
		// 	 	mesh:null
		// },
		}
		//网格索引
		var meshes={};
		
		
		//光源
		function initLight(){ 
		ambientLight=new THREE.AmbientLight(0xfcffbc,0.8);//浅蓝色
		pointLight=new THREE.PointLight(0x000000,0.8,1);
		pointLight.position.set(0,60,0);
		pointLight.castShadow=true;
		//pointLight.receiveShadow=true;
		scene.add(ambientLight);
		scene.add(pointLight);
		}
			
		
		camera.position.x = 0;
		camera.position.y = 0;
		camera.position.z = -70;
		camera.lookAt(scene.position);
	
		
		//创建地平面
		function CreatePanl() {
		            // var floor_1 = THREE.ImageUtils.loadTexture("textures/ground/grasslight-big.jpg");
		            // floor_1.wrapS = THREE.RepeatWrapping;
		            // floor_1.wrapT = THREE.RepeatWrapping;
		            // floor_1.repeat.set(4, 4);
		            //var floor_1Material = new THREE.MeshLambertMaterial({ map: floor_1 });
		            var planeGeometry = new THREE.PlaneGeometry(300,300,100,10);
		            planeMaterial = new THREE.MeshBasicMaterial({ color: 0xd6d6d6/*,map:floor_1,specular: 0xffffff, shininess: 200 */});
		            plane = new THREE.Mesh(planeGeometry, planeMaterial);
		          
					
					plane.receiveShadow = true;
		            plane.rotation.x = -0.5 * Math.PI;
		            plane.position.x = camera.position.x;
		            plane.position.y = camera.position.y-20;
		            plane.position.z = camera.position.z+150;
		            scene.add(plane);
		        }
		
		 
		//加载模型,只调用一次就够了，无论加载几个模型
		for(var _key in models){
		    (function(key){    
			    //加载模型和材质---->女模特
			    var mtlLoader=new THREE.MTLLoader(loadingManager);
			    mtlLoader.load(models[key].mtl,function(materials){
				    materials.preload();
				    var objLoader=new THREE.OBJLoader(loadingManager);
				    objLoader.setMaterials(materials);
				    objLoader.load(models[key].obj,function(mesh){
					    //给加载的人物模型加上阴影
					    mesh.traverse(function(node){
						    if(node instanceof THREE.Mesh){
								//不给枪加阴影，给其他模型加阴影
								node.material.transparent=true;//透明材质，可以显示树枝丫
								if("castShadow" in models[key]) 
								    node.castShadow=models[key].castShadow;
								else
								    node.castShadow=false;
								if("receiveShadow" in models[key]) 
								    node.receiveShadow=models[key].receiveShadow;
								else
								    node.receiveShadow=false;
							    //node.castShadow=true;
							    //node.receiveShadow=true;
						    }//, onProgress, onError 
					    });
						models[key].mesh=mesh;
				    });
			    });
		    })(_key)
		}
		
		// // 加载 obj 文件
		//     var loader = new THREE.OBJMTLLoader();
		//     loader.load('MQ-9.obj', 'MQ-9.mtl', function(object) {
		//             scene.add(object);
		//     });
		
		function onResourceLoaded(){
			//将模型克隆到网络中
			meshes["school"]=models.school.mesh.clone();
			//不知道为什么，使用这种方法，必须要有loadingManager，不然mesh为null值
			meshes["school"].position.set(-2.5,-10,25);
			meshes["school"].scale.set(0.005,0.005,0.005);
			meshes["school"].rotation.y+=Math.PI/2;
			scene.add(meshes["school"]);
			
            
            // meshes["Garen"]=models.Garen.mesh.clone();
            // meshes["Garen"].position.set(0,0,0);
            // meshes["Garen"].scale.set(10000,10000,10000);
            // scene.add(meshes["Garen"]);
		}

		//camera大小随窗口变化
		function onResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}
		
		init();
		function init(){
			initLight();
			CreatePanl();
			initControls();
		}
		
		
		animate();
		function animate(){
			//在加载资源时运行此代码
			if(Resource_Loaded==false){
				requestAnimationFrame(animate);
				loadingScreen.box.position.x-=0.05;
				renderer.setClearColor(new THREE.Color(0x55aaff));
				if(loadingScreen.box.position.x<-10)
				loadingScreen.box.position.x=10;
				loadingScreen.box.position.y=Math.sin(loadingScreen.box.position.x);
				renderer.render(loadingScreen.scene,loadingScreen.camera);
				return;
			}

			//更新鼠标控制
			controls.update();

		   	requestAnimationFrame(animate);
			  //mesh.rotation.x += 0.01;
			  //mesh.rotation.y += 0.02;
		   	renderer.render(scene,camera);
			
			if(keyboard[83]){ //敲W键
								   //Math.sin/cos返回值为-1到1之间的数
								   camera.position.x-=Math.sin(camera.rotation.y)*player.speed;
			    camera.position.z-=Math.cos(camera.rotation.y)*player.speed;
			}
			
			if(keyboard[87]){ //敲s键
					camera.position.x+=Math.sin(camera.rotation.y)*player.speed;
			     camera.position.z+=Math.cos(camera.rotation.y)*player.speed;
			}
			
			if(keyboard[65]){ //敲A键
					camera.position.x+=Math.sin(camera.rotation.y+
									                   Math.PI/2)*player.speed;
			     camera.position.z-=Math.cos(camera.rotation.y+
									                   Math.PI)*player.speed;
			}
			
			if(keyboard[68]){ //敲D键
					camera.position.x+=Math.sin(camera.rotation.y-
									   Math.PI/2)*player.speed;
			     camera.position.z-=Math.cos(camera.rotation.y-
									   Math.PI)*player.speed;
								}
								
			 if(keyboard[37]){ //左箭头键
				camera.rotation.y-=player.turnSpeed;
							}
								
			if(keyboard[39]){ //右箭头键
				camera.rotation.y+=player.turnSpeed;
							}
			
			if(keyboard[38]){ //上箭头键
				camera.position.y+=player.speed;
							}
								
			if(keyboard[40]){ //下箭头键
				camera.position.y-=player.speed;
							}

		   }

			//初始化鼠标控制
			function initControls() {

				controls = new THREE.OrbitControls(camera, renderer.domElement);
				//设置控制器的中心点
				//controls.target.set( 0, 5, 0 );
				// 如果使用animate方法时，将此函数删除
				//controls.addEventListener( 'change', render );
				// 使动画循环使用时阻尼或自转 意思是否有惯性
				controls.enableDamping = true;
				//动态阻尼系数 就是鼠标拖拽旋转灵敏度
				//controls.dampingFactor = 0.25;
				//是否可以缩放
				controls.enableZoom = true;
				//是否自动旋转
				controls.autoRotate = false;
				controls.autoRotateSpeed = 0.5;
				//设置相机距离原点的最远距离
				controls.minDistance = 1;
				//设置相机距离原点的最远距离
				controls.maxDistance = 2000;
				//是否开启右键拖拽
				controls.enablePan = true;
			}

		   function keyDown(event){ //当按下键时触发
		   	keyboard[event.keyCode]=true;
		   }
		   
		   function keyUp(event){ //当按键结束时触发
		   	keyboard[event.keyCode]=false;
		   }
		   
		   window.addEventListener('keydown',keyDown);
		   window.addEventListener('keyup',keyUp);
		   window.addEventListener('resize', onResize, false);
		</script>
	</body>
</html>
